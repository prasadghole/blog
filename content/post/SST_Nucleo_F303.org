#+options: ':nil -:nil ^:{} num:nil 
#+author: Prasad Ghole.
#+creator: Emacs 28.2 (Org mode 9.6.6 + ox-hugo)
#+hugo_with_locale:
#+hugo_front_matter_format: toml
#+hugo_level_offset: 1
#+hugo_preserve_filling:
#+hugo_delete_trailing_ws:
#+hugo_section: post
#+hugo_bundle:
#+hugo_base_dir: ../../
#+hugo_goldmark:
#+hugo_code_fence:
#+hugo_use_code_for_kbd:
#+hugo_prefer_hyphen_in_tags:
#+hugo_allow_spaces_in_tags:
#+hugo_auto_set_lastmod:
#+hugo_custom_front_matter: showTableOfContents true
#+hugo_blackfriday:
#+hugo_front_matter_key_replace:
#+hugo_date_format: %Y-%m-%dT%T%z
#+hugo_paired_shortcodes:
#+hugo_pandoc_citations:
#+bibliography:
#+html_container:
#+html_container_class:
#+hugo_aliases:
#+hugo_audio:
#+date: <2023-07-29 Sat>
#+description:
#+hugo_draft: true
#+hugo_expirydate:
#+hugo_headless:
#+hugo_images:
#+hugo_iscjklanguage:
#+keywords:
#+hugo_layout:
#+hugo_lastmod:
#+hugo_linktitle:
#+hugo_locale:
#+hugo_markup:
#+hugo_menu:
#+hugo_menu_override:
#+hugo_outputs:
#+hugo_publishdate:
#+hugo_series:
#+hugo_slug:
#+hugo_tags:
#+hugo_categories:
#+hugo_resources:
#+hugo_type: post
#+hugo_url:
#+hugo_videos:
#+hugo_weight:

#+TITLE: Porting SST on Nucleo F303
The Quantum Framework, developed by Miro Samek, is a software framework designed for building event-driven, reactive embedded systems. It provides a structured approach to software development, emphasizing modularity, reusability, and scalability.

At the core of the Quantum Framework is the concept of hierarchical state machines (HSMs), which are used to model the behavior of the system. HSMs allow for the representation of complex system behaviors in a hierarchical and modular manner, making it easier to understand and maintain the software.

* Super Simple Tasker
Instead of moving to this full fledge framework from bare metal programs. Super simple tasker also known as hardware based RTOS.
Using nested vectore controller features to simulate preemptive kernel, also saving overhead of private stack for each task.

* Porting on Nucleo board F303
Example code provided in SST repository [[https://github.com/QuantumLeaps/Super-Simple-Tasker][SST]] for nucleo l053 controller. Below are steps I followed
for porting blinky example F303.

After creating standard project in STM32CubeIDE using seperate INC/SRC structre.
** Imported kernel files from below folders to respective
INC/SRC folders.
1. sst.c
2. sst_port.c from (ports/arm-cm)
3. sst_port.h from (ports/arm-cm)
4. sst.h
5. dbc_assert.h
** Import bsp files
1. bsp_nucleo-l053r8.c
This file uses basic low level drivers. In order to make it HAL compatible and to
map LED 2 on nucleo board made changes to device specific header file and called initialization
from MX library.

** Main.c
Finally copied the main.c from example folder.

* Porting Blinky_Button example
In previous section I have ported blinky example. Which uses simple timer events without
any event data. Blinky button example provide passing events with data. Basic
principle is making sure base of event structure is always event number or signal. Then
during event processing downcasting to appropriate structure for getting additional
data with respect to that event.
** BSP
As I am adding more bsp functions, instead of merging example code, better approch is
make seperte BSP project for nucleo board. This way hardware mapping related changes
will remain seperate.

** ISR selection
As we will be repurposing ISR supported by micro, we need to plan on which ISR to be used

** STM32Cube and SST code integration
There are some challanges which needs to be addressed as autogenerated code can intermingle
with SST code.
*** ISR
Do not enable ISR repurposed in CubeMX project.
*** Main.c
By defualt MX cube create main.c, to skip either we can remove it from build or add
proper user define code.

* Modular Project managment
Main application will consist of below components
1. Application Logic (main_app.c) entry point
2. SSTc library linking
3. BSP 
  
** Application
This can be 

* Creating STM32 BSP Project as library
STM32CubeIDE do not provide direct way to create auto generated code similer to CubeMX
hence we have to create CubeMX project first and then create new STM32 cube project
from it.
[[/images/stm32/NewProject.png]]

But there is no option to create library, hence we have to convert the output to
library by changing the build settings.

[[/images/stm32/createlib.png]]

* SST Template application
** Design
*** Active objects Identification
We have to first identify tasks or active objects in our project. Lets say for simplicity
we have LED driver turning LED on or off. So we can wrap LED driver in task, which takes
input events LED_ON and LED_OFF.
*** Signals and events
Enumerate all the signals this AO is going to handle. We can have globally identified
events so that all the AO can communicate with each other with central event repository.

#+begin_src c
  enum Signals {
    LED_ON,
    LED_OFF,
    MAX_SIG
  };
#+end_src

Now for each signal type we have to derive event structure from ~SST_Evt~ as base
member with addional signal data. For this example we can select LED number assuming
there is single AO controlling many LED on board.

We define event structure as
#+begin_src c
  typedef struct {
    SST_Evt super; /*< inherit from SST_evt */
    uint32_t pin;  /*< Pin number  */
  }LED_Evt;
#+end_src

*** Task Structure
Now we will create worker AO with initialize and AO task handler.
#+begin_src  c
  typedef struct {
    SST_Task super;
  }LED_AO;
#+end_src
As we will be referring pointer to AO base class/struct, it is much better to create
pointer reference for easy use.
#+begin_src c
  static LED_AO LED_AO_Instance;
  SST_Task * const ptrLED_AO = &LED_AO_Instance.super;
#+end_src
**** Define functions for AO
#+begin_src c
  /* Counstroctor this is private function to be called from initialziation interface */
  static void LEDAO_ctor(LED_AO * const me);
  /* Initialie function with initial event */
  static void LEDAO_init(LED_AO * const me, SST_Evt const * const ie);
  /* Task function */
  static void LEDAO_dispatch(LED_AO * const me, SST_Evt const * const e);
#+end_src

**** Create SST tasks
We will bind the tasks init and dispatch functions
#+begin_src c
  static void LEDAO_ctor(LED_AO * const me)
  {
    SST_Task_ctor(&me->super,
		  (SST_Handler)&LEDAO_init,
		  (SST_Handler)&LEDAO_dispatch);
  }
#+end_src

**** Dispatcher
This function will be of prototype SST handler 
#+begin_src  c
  static void LEDAO_dispatch(LED_AO * const me, SST_Evt const * const e)
  {
    switch(e->sig)
      {
      case LED_ON:
	break;
      case LED_OFF:
	break;
      }
  }
#+end_src

** Interrupts Assignments
Based on microcontroller used we have to find unused interrupts for
calling task handlers. In case of Nucleo-F303RE we can use PVD interrupt
number for LED AO.
[[/images/stm32/nvic.png]]

We should assign it using ~SST_Task_setIRQ~ function.
#+begin_src c
  SST_Task_setIRQ(LED_AO,PVD_IRQn);
#+end_src
Once set we have to bind this ISR call to our dispatch function.
#+begin_src c
  void PVD_IRQHandler(void)
  {
    SST_Task_activate(ptrLED_AO);
  }
#+end_src

** Event storage
AO needs event queue for storing incoming event request. We have to create array
of poin
#+begin_src c
  static SST_Evt const * LED_AOq[10];
#+end_src
** AO Runtime creation
Once above things are setup its now time for putting AO in action. To do this we need to call
~SST_Task_start~ function as
#+begin_src c
  SST_Task_start(ptrLED_AO,1U,LED_AOq,ARRAY_NELEM(LED_AOq),(SST_Evt const *)0);
#+end_src

** SST Callbacks (Hooks)
*** SST_onStart`
We need to provide hook function which get called from ~SST_Task_run~ function.
For F303RE
#+begin_src c
  /* SST callbacks ===========================================================*/
  void SST_onStart(void) {
    SystemCoreClockUpdate();

    /* set up the SysTick timer to fire at BSP_TICKS_PER_SEC rate */
    SysTick_Config((SystemCoreClock / BSP_TICKS_PER_SEC) + 1U);

    /* set priorities of ISRs used in the system */
    NVIC_SetPriority(SysTick_IRQn, 0U);
    /* ... */
  }
  /*..........................................................................*/
  void SST_onIdle(void) {
  #ifdef NDEBUG
    __WFI(); /* Wait-For-Interrupt */
  #endif
  }

#+end_src

** Supporting ISR
Apart from repurposed ISRs we also need basic system ISR for SST kernel for
timebase and timer activities.
#+begin_src c
  void SysTick_Handler(void)
  { /* system clock tick ISR */
    SST_TimeEvt_tick(); /* process all SST time events */
  }
#+end_src
** Start
Once all the setup are complete we can start scheduler by calling ~SST_Task_run~
This function shall never return.
#+begin_src c
  return SST_Task_run();
#+end_src
** Main putting it all togethor
#+begin_src c
  int main(void)
  {
    SST_init();
    System_Init();

    LEDAO_Initialize();

    static SST_Evt const *LED_AOq[10];

    SST_Task_start(ptrLED_AO, 1U, LED_AOq, ARRAY_NELEM(LED_AOq),
		   (SST_Evt const*) 0);

    return SST_Task_run();
  }

#+end_src

* SST C++ Template application
C++ provides much natural feel of writing object oriented application as we don't
have to be SUPER careful to make sure I am passing correct data.

** Design
Design exercise remain same in C and C++. Only implmentation and inter mixing
of C and C++ code should be taken care.

*** Active Object
All the actie objects should be derived from task class
#+begin_src c++
  class LED_AO : public SST::Task {
  public:
  LED_AO(void);
  void init(SST::Evt const * const ie) override;
  void dispatch(SST::Evt const * const e) override;
  }; 
#+end_src

We don't require explicite constructor as C++ compiler takes care of it.

*** Events
For simple design events and signals are still same as C implmentation
#+begin_src c++ 
  enum Signals {
    LED_ON,
    LED_OFF,
    MAX_SIG
  };
  struct {
    SST::SST_Evt super; /*< inherit from SST_evt */
    uint32_t pin;  /*< Pin number  */
  }LED_Evt;

#+end_src
